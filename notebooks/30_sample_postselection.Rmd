## Sample Processing with BioQC {#sample-processing}

```{r setup, include=FALSE}
library(sqldf)
library(dplyr)
library(readr)
library(stringr)
library(data.table)
library(gridExtra)
library(VennDiagram)
library(knitr)
library(ggplot2)
library(BioQC)
library(Hmisc)
```

```{r load-data-postselection, include=FALSE, cache=FALSE, cache.lazy=FALSE}
CACHE_FILE = "../results/bioqc_db_cache.RData"
if(!file.exists(CACHE_FILE)) {
  bioqc_bioqc_success = read_csv("../data/bioqc_geo_oracle_dump/BIOQC_BIOQC_SUCCESS_DATA_TABLE.csv")
  bioqc_gsm = read_csv("../data/bioqc_geo_oracle_dump/BIOQC_GSM_DATA_TABLE.csv")
  bioqc_gse_gsm = read_csv("../data/bioqc_geo_oracle_dump/BIOQC_GSE_GSM_DATA_TABLE.csv")
  bioqc_normalize_tissues = read_csv("../data/bioqc_geo_oracle_dump/BIOQC_NORMALIZE_TISSUES_DATA_TABLE.csv")
  bioqc_gse_gpl = read_csv("../data/bioqc_geo_oracle_dump/BIOQC_GSE_GPL_DATA_TABLE.csv")
  bioqc_signatures = read_csv("../data/bioqc_geo_oracle_dump/BIOQC_SIGNATURES_DATA_TABLE.csv")
  bioqc_res = read_csv("../data/bioqc_geo_oracle_dump/BIOQC_RES_DATA_TABLE.csv")
  bioqc_selected_samples = read_csv("../data/bioqc_geo_oracle_dump/materialized_views/BIOQC_SELECTED_SAMPLES_DATA_MATERIALIZED VIEW.csv")
  save(bioqc_bioqc_success, bioqc_gsm, bioqc_gse_gsm, bioqc_normalize_tissues,
       bioqc_gse_gpl, bioqc_signatures, bioqc_res, bioqc_selected_samples,
       file=CACHE_FILE, compress=FALSE)
} else {
  load(CACHE_FILE)
}
```

The following processes are ressource intensive, therefore we execute them on a high performance cluster (HPC). We use [chunksub](https://github.com/grst/chunksub) to distribute the [list of sample ids](#sample-list) to the workers. This involves four major steps which are also documented in the project's [Makefile](https://github.com/grst/BioQC_GEO_analysis/blob/master/Makefile).

1. We download the studies with [GEOquery](https://bioconductor.org/packages/release/bioc/html/GEOquery.html) and store them as R [ExpressionSet](https://bioconductor.org/packages/devel/bioc/vignettes/Biobase/inst/doc/ExpressionSetIntroduction.pdf) using the R script [geo_to_eset.R](https://github.com/grst/BioQC_GEO_analysis/blob/master/scripts/geo_to_eset.R). For some series, the download is not successful.
2. We annotated human orthologous genes for all studies using [ribiosAnnotation](https://github.com/Accio/ribios) in [annotate_eset.R](https://github.com/grst/BioQC_GEO_analysis/blob/master/scripts/annotate_eset.R). This is necessary as the tissue signatures are built on a human dataset. The annotation failes for species which are not in the *ribios* database.
3. We run *BioQC* on these studies use [run_bioqc.R](https://github.com/grst/BioQC_GEO_analysis/blob/master/scripts/run_bioqc.R).
4. Finally, [import the BioQC results into the database](#import-bioqc-results).


## Sample Post-selection

The failures during download and annotation reduce the number of samples available to our study.

<!-- since there are muliple gpl and gsm in a gse, there might've been some gsm
inserted, that don't have a tissue annotated, although the gse was selected. -->

```{r after_failures, cache=TRUE}
count_gse_gsm = function(tbl) {
  summarise(tbl, GSM=n_distinct(GSM), GSE=n_distinct(GSE))
}

tmp_tbl = bioqc_bioqc_success %>%
  inner_join(bioqc_gsm, by=c("GSM"="GSM")) %>%
  inner_join(bioqc_gse_gsm, by=c("GSM"="GSM"))

tmp_tbl %>%
  count_gse_gsm() %>%
  kable()
```


### Excluding multi-channel microarrays

Multi channel microarrays date back to the early age of gene expression studies. They don't provide absolute gene expression data and are not meaningful outside their experimental context. We therefore exclude these experiments:
```{r exclude_multichannel, cache=TRUE}
tmp_tbl2 = tmp_tbl %>%
  filter(CHANNEL_COUNT == 1)

tmp_tbl2 %>%
  count_gse_gsm() %>%
  kable()
```

### Exclude non-mapped tissues
We exclude samples that have a tissue annotated, but it is not mapped to a [normalized tissue](#tissue-normalization).

```{r normalize_tissue, cache=TRUE}
tmp_tbl3 = tmp_tbl2 %>%
  mutate(TISSUE_ORIG=tolower(TISSUE_ORIG)) %>%
  inner_join(bioqc_normalize_tissues, by=c("TISSUE_ORIG"="TISSUE_ORIG"))

tmp_tbl3 %>%
  count_gse_gsm() %>%
  kable()
```

### Select organisms
We were interested in the organism distribution.
```{r filter_orga, cache=TRUE}
tmp_tbl3 %>%
  group_by(ORGANISM_CH1) %>%
  count_gse_gsm() %>%
  arrange(-GSM) %>%
  kable()
```

Results suggest that it makes sense to limit the analysis to the three main organisms: *H. sapiens*, *M. musculus*, *R. norvegicus*. This makes also sense as these species are closesly related and therefore the signatures are more likely to translate within these species.
We are left with the following amount of samples:

```{r filter_orga2, cache=TRUE}
tmp_tbl5 = tmp_tbl3 %>%
  filter(ORGANISM_CH1 %in% c('Homo sapiens', 'Mus musculus', 'Rattus norvegicus'))

tmp_tbl5 %>%
  count_gse_gsm() %>%
  kable()
```

### Quality control

In this step we seek to identify studies on which BioQC cannot work due to poor data quality or data processing steps that remove the relative expression of a gene within a sample, e.g. per-gene normalization.
We will first filter samples by applying a cutoff-value to statistics on the gene expression data. Second, we will use an ubiquitous signature containing housekeeping genes as an indicator if BioQC returns a sensible result on the given sample.

On each study, we have calculated the mean of each gene over all samples. Of this series of means, we calculate the IQR. If a per-gene normalization has been applied, this value should be close to zero. This histogram shows a distribution of all IQRs over all remaining studies:

```{r study_iqr, cache=FALSE, fig.cap="Histogram of the distribution of all inter quartile ranges of all studies remaining at this filtering step. The vertical line shows the filtering cutoff used. "}
tbl_hist = tmp_tbl5 %>%
  inner_join(bioqc_gse_gpl, by=c("GSE"="GSE", "GPL"="GPL")) %>%
  mutate(IQR=abs(STUDY_75-STUDY_25))

sm = tbl_hist$IQR
hist(sm[sm > 0 & sm < 25],
     breaks=seq(0, 25, .25),
     main="Variance between gene for each study (IQR)",
     xlab="median gene expression (only values up to 25)")
abline(v=.5, col="blue")
minor.tick(nx=5)
```

We exclude all studies having a very low variance between genes (IQR < 0.5). Remaining samples:

```{r exclude_iqr, cache=TRUE}
tmp_tbl6 = tbl_hist %>%
  filter(IQR >= .5)

tmp_tbl6 %>%
  count_gse_gsm() %>%
  kable()
```

Now, we have a look at the p-value distribution of the signature we called `awesome_housekeepers` containing ubiquitous genes. The gene expression of these genes can be assumed to be more or less constant over all tissue types, therefore this signature should score high in every sample.

**Awesome Housekeepers**
```{r hk_gene_list, cache=TRUE, echo=TRUE, include=FALSE}
res = sqldf("select * from bioqc_signatures where id = 56184")
str_replace_all(res$GENE_SYMBOLS, ",", ", ")
```

```{r, cache=TRUE}
tmp_bioqc_res = bioqc_signatures %>%
  filter(ID %in% c(56184, 56206)) %>% # awesome_housekeepers, random_100_0
  inner_join(bioqc_res, by=c("ID"="SIGNATURE")) %>%
  rename(SIGNATURE=ID)

tbl_hk = tmp_tbl6 %>%
  inner_join(tmp_bioqc_res, by=c("GSM"="GSM")) %>%
  mutate(SCORE=absLog10p(as.numeric(PVALUE)))
```

```{r, echo=FALSE, fig.cap="The orange curve is the pvalue distribution of the housekeeping signature. The blue curve shows the distribution of a random control signature containing 100 randomly chosen genes. The vertical line represents the p-value cutoff used in this filtering step"}
ggplot(tbl_hk, aes(x=SCORE)) +
  geom_density(aes(color=NAME)) +
  geom_vline(xintercept = 5, color="blue") +
  theme(legend.position = "top")
```

We exclude all samples for which `awesome_housekeepers` scores with < 5, i.e. pvalue >= 1e-5.
```{r filter_housekeeping, cache=TRUE}
tmp_tbl7 = tbl_hk %>%
  filter(SIGNATURE == 56184) %>%
  filter(PVALUE < 1e-5)

tmp_tbl7 %>%
  count_gse_gsm() %>%
  kable()
```

This is the 'background' of samples on which we test for tissue contamination.
We store the selected samples alongside with meta information required for the analysis in the materialized view `BIOQC_SELECTED_SAMPLES` in our DBS. [Here](https://github.com/grst/BioQC_GEO_analysis/blob/master/db/views/sample_selection.sql) is the SQL script generating the materialized view.


### Tissue abundance

The following table shows how many samples are available for each tissue:
```{r tissues, cache=TRUE}
bioqc_selected_samples %>%
  group_by(TISSUE) %>%
  summarise(samples=n_distinct(GSM)) %>%
  arrange(-samples) %>%
  kable()
```
